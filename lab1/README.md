# Решение задач линейного программирования симплекс-методом

## Автор
**Богданов Максим Александрович**  
**Поток:** МЕТОПТ 1.1

---

## Краткое описание алгоритма решения ЗЛП

### Двухфазный симплекс-метод (псевдокод)

```
АЛГОРИТМ: Решение ЗЛП двухфазным симплекс-методом
ВХОД: 
    - Целевая функция: max/min c₁x₁ + c₂x₂ + ... + cₙxₙ
    - Ограничения: aᵢ₁x₁ + aᵢ₂x₂ + ... + aᵢₙxₙ {<=, =, >=} bᵢ
    - Условия неотрицательности: xⱼ ≥ 0 (или свободные переменные)

ВЫХОД: 
    - Оптимальная точка x* = (x₁*, x₂*, ..., xₙ*)
    - Значение целевой функции W(x*)
    - ИЛИ сообщение об отсутствии решения

--------------------------------------------------------

ШАГ 1. ЧТЕНИЕ ВХОДНЫХ ДАННЫХ
    Прочитать файл с постановкой задачи
    Извлечь: тип задачи (max/min), коэффициенты c, матрицу A, вектор b
    Определить: n - количество переменных, m - количество ограничений
    Прочитать список свободных переменных (если есть)
    
    ДЛЯ каждой свободной переменной xᵢ:
        Заменить xᵢ = xᵢ⁺ - xᵢ⁻, где xᵢ⁺, xᵢ⁻ ≥ 0
        Обновить коэффициенты в целевой функции и ограничениях

--------------------------------------------------------

ШАГ 2. ПРИВЕДЕНИЕ К КАНОНИЧЕСКОМУ ВИДУ
    ДЛЯ каждого ограничения i = 1..m:
        ЕСЛИ тип ограничения "<=":
            Добавить slack переменную sᵢ ≥ 0
            aᵢ₁x₁ + ... + aᵢₙxₙ + sᵢ = bᵢ
        
        ЕСЛИ тип ограничения ">=":
            Добавить surplus переменную sᵢ ≥ 0
            Добавить искусственную переменную rᵢ ≥ 0
            aᵢ₁x₁ + ... + aᵢₙxₙ - sᵢ + rᵢ = bᵢ
        
        ЕСЛИ тип ограничения "=":
            Добавить искусственную переменную rᵢ ≥ 0
            aᵢ₁x₁ + ... + aᵢₙxₙ + rᵢ = bᵢ
    
    Сформировать расширенную симплекс-таблицу

--------------------------------------------------------

ФАЗА 1: ПОИСК НАЧАЛЬНОГО ДОПУСТИМОГО БАЗИСА

ШАГ 3. ФОРМИРОВАНИЕ ВСПОМОГАТЕЛЬНОЙ ЗАДАЧИ
    Создать целевую функцию вспомогательной задачи:
        w = r₁ + r₂ + ... + rₖ → min
        где rᵢ - искусственные переменные
    
    Обнулить коэффициенты при базисных переменных в строке w

--------------------------------------------------------

ШАГ 4. РЕШЕНИЕ ВСПОМОГАТЕЛЬНОЙ ЗАДАЧИ
    iteration = 0
    
    ПОКА НЕ достигнут оптимум И iteration < MAX_ITERATIONS:
        iteration = iteration + 1
        
        // Шаг 4.1: Проверка критерия оптимальности
        ЕСЛИ все коэффициенты в строке w ≤ 0:
            ЗАВЕРШИТЬ ФАЗУ 1  // Оптимум найден
        
        // Шаг 4.2: Выбор входящей переменной (ведущий столбец)
        j* = arg max{wⱼ : wⱼ > 0}  // Максимальный положительный
        
        // Шаг 4.3: Выбор выходящей переменной (ведущая строка)
        // Минимальное симплексное отношение (min ratio test)
        i* = arg min{bᵢ/aᵢⱼ* : aᵢⱼ* > 0}
        
        ЕСЛИ все aᵢⱼ* ≤ 0:
            ВЕРНУТЬ "Задача неограничена"
        
        ЕСЛИ минимальное отношение = 0:
            ВЫВЕСТИ "Предупреждение: вырождение"
        
        // Шаг 4.4: Обновление базиса
        Заменить базисную переменную в строке i* на переменную j*
        
        // Шаг 4.5: Пересчёт симплекс-таблицы
        pivot = aᵢ*ⱼ*
        
        // Нормализация ведущей строки
        ДЛЯ всех j:
            aᵢ*ⱼ = aᵢ*ⱼ / pivot
        
        // Обнуление ведущего столбца
        ДЛЯ всех i ≠ i*:
            multiplier = aᵢⱼ*
            ДЛЯ всех j:
                aᵢⱼ = aᵢⱼ - multiplier × aᵢ*ⱼ

--------------------------------------------------------

ШАГ 5. ПЕРЕХОД К ОСНОВНОЙ ЗАДАЧЕ
    // Шаг 5.1: Проверка допустимости
    ЕСЛИ w_min > ε:  // ε - малая величина (10⁻¹⁰)
        ВЕРНУТЬ "Задача не имеет допустимых решений (несовместна)"
    
    // Шаг 5.2: Проверка базиса
    ЕСЛИ хотя бы одна искусственная переменная в базисе:
        ВЕРНУТЬ "Задача несовместна"
    
    // Шаг 5.3: Удаление искусственных переменных
    Удалить столбцы всех искусственных переменных из таблицы
    
    Допустимый базис найден → переход к ФАЗЕ 2

--------------------------------------------------------

ФАЗА 2: ОПТИМИЗАЦИЯ ЦЕЛЕВОЙ ФУНКЦИИ

ШАГ 6. РЕШЕНИЕ ОСНОВНОЙ ЗАДАЧИ
    // Шаг 6.1: Установка исходной целевой функции
    Заменить строку w на исходную целевую функцию z
    
    ЕСЛИ задача на минимум:
        Инвертировать знаки коэффициентов z
    
    // Шаг 6.2: Обнуление коэффициентов при базисных переменных
    ДЛЯ каждой базисной переменной xⱼ:
        ЕСЛИ zⱼ ≠ 0:
            Вычесть из строки z соответствующую строку ограничений,
            умноженную на zⱼ
    
    // Шаг 6.3: Итерации симплекс-метода (аналогично Фазе 1)
    iteration = 0
    
    ПОКА НЕ достигнут оптимум И iteration < MAX_ITERATIONS:
        iteration = iteration + 1
        
        // Для задачи максимизации
        ЕСЛИ задача = "max":
            ЕСЛИ все коэффициенты в строке z ≥ 0:
                ЗАВЕРШИТЬ ФАЗУ 2  // Оптимум найден
            
            j* = arg min{zⱼ : zⱼ < 0}  // Наиболее отрицательный
        
        // Для задачи минимизации
        ИНАЧЕ:
            ЕСЛИ все коэффициенты в строке z ≤ 0:
                ЗАВЕРШИТЬ ФАЗУ 2  // Оптимум найден
            
            j* = arg max{zⱼ : zⱼ > 0}  // Наиболее положительный
        
        // Выбор выходящей переменной (min ratio test)
        i* = arg min{bᵢ/aᵢⱼ* : aᵢⱼ* > 0}
        
        ЕСЛИ все aᵢⱼ* ≤ 0:
            ВЕРНУТЬ "Целевая функция неограничена"
        
        // Обновление базиса и пересчёт таблицы
        Обновить базис и пересчитать симплекс-таблицу
        (аналогично шагам 4.4-4.5)
    
    // Шаг 6.4: Извлечение решения
    ДЛЯ j = 1..n:
        ЕСЛИ xⱼ - базисная переменная:
            xⱼ* = значение из столбца правых частей
        ИНАЧЕ:
            xⱼ* = 0
    
    z* = значение целевой функции из правого столбца
    
    ЕСЛИ задача на минимум:
        z* = -z*

--------------------------------------------------------

ШАГ 7. ЗАПИСЬ РЕЗУЛЬТАТА В ФАЙЛ
    Записать в выходной файл:
        "Оптимальная точка x*:"
        ДЛЯ j = 1..n:
            "xⱼ = xⱼ*"
        
        "Значение целевой функции W(x*) = z*"
        "Количество итераций: iteration"

--------------------------------------------------------

КОНЕЦ АЛГОРИТМА
```

---

## Инструкция по развертыванию и запуску

### Требования

- **Python:** версия 3.6 или выше
- **Библиотеки:** используются только стандартные библиотеки Python

### Установка

1. **Клонирование или скачивание проекта:**
   ```bash
   git clone https://github.com/exPriceD/optimization-methods-labs.git
   cd lab1
   ```
   
   Или просто скопируйте файлы `simplex.py`, `main.py` и `input.txt` в одну директорию.

2. **Проверка версии Python:**
   ```bash
   python --version
   ```
   Должна быть версия 3.6 или выше.

### Подготовка входных данных

Создайте файл `input.txt` в той же директории, где находятся Python-файлы.

**Формат файла `input.txt`:**

```
max: 4x_1 + 1x_2 + 2x_3 + 3x_4
constraints:
    1x_1 + 1x_2 + 1x_3 <= 9
    1x_2 + 2x_3 + 1x_4 = 7
    1x_1 + 1x_4 >= 3
free_variables: x_3
```

**Правила оформления:**
- Первая строка: `max` или `min`, затем двоеточие и целевая функция
- Строка `constraints:` обозначает начало ограничений
- Каждое ограничение на новой строке
- Формат переменной: `коэффициент x_индекс` (например, `3x_1`, `2x_2`)
- Поддерживаемые операторы: `<=`, `>=`, `=`
- Правая часть - число после оператора
- Блок `free_variables:` (опционально) — список свободных переменных через пробел
- Свободные переменные могут принимать любые значения (в том числе отрицательные)
- Комментарии начинаются с `#`

### Запуск программы

```bash
python main.py
```

### Результат работы

После успешного выполнения программа:
1. Прочитает задачу из `input.txt`
2. Решит её по всем 7 шагам двухфазного симплекс-метода
3. Выведет результат в консоль
4. Создаст файл `output.txt` с подробным решением

**Пример вывода в консоли:**
```
[Шаг 1] Считывание файла input.txt...
+ Файл успешно прочитан

Целевая функция: max z = 4x_1 + 1x_2 + 2x_3 + 3x_4
Количество переменных: 4
Количество ограничений: 3

Ограничения:
  1. 1x_1 + 1x_2 + 1x_3 <= 9
  2. 1x_2 + 2x_3 + 1x_4 = 7
  3. 1x_1 + 1x_4 >= 3

[Шаг 2] Приведение задачи к каноническому виду...
[Шаг 3-4] Формирование и решение вспомогательной задачи...
[Шаг 5] Переход к основной задаче...
[Шаг 6] Решение основной задачи...
+ Оптимальное решение найдено

============================================================
Результат
============================================================

Оптимальная точка x*:
  x_1 = 9.000000
  x_2 = 0.000000
  x_3 = 0.000000
  x_4 = 7.000000

Значение целевой функции W(x*): 57.000000
Количество итераций: 6

[Шаг 7] Запись результата в файл output.txt...
+ Результат записан в файл

============================================================
Успешное завершение
============================================================
```

---

## Демонстрация работы программы

### Вариант задания

**Задача:**

Найти максимум функции:
```
z = 4x₁ + x₂ + 2x₃ + 3x₄ → max
```

при ограничениях:
```
x₁ + x₂ + x₃ ≤ 9
x₂ + 2x₃ + x₄ = 7
x₁ + x₄ ≥ 3
x₁, x₂, x₃, x₄ ≥ 0
```

### Решение

#### Шаг 1: Подготовка `input.txt`

```
max: 4x_1 + 1x_2 + 2x_3 + 3x_4
constraints:
    1x_1 + 1x_2 + 1x_3 <= 9
    1x_2 + 2x_3 + 1x_4 = 7
    1x_1 + 1x_4 >= 3
```

#### Шаг 2: Запуск программы

```bash
python main.py
```

#### Шаг 3: Вывод программы

```
[Шаг 1] Считывание файла input.txt...
+ Файл успешно прочитан

Целевая функция: max z = 4x_1 + 1x_2 + 2x_3 + 3x_4
Количество переменных: 4
Количество ограничений: 3

Ограничения:
  1. 1x_1 + 1x_2 + 1x_3 <= 9
  2. 1x_2 + 2x_3 + 1x_4 = 7
  3. 1x_1 + 1x_4 >= 3

[Шаг 2] Приведение задачи к каноническому виду...
[Шаг 3-4] Формирование и решение вспомогательной задачи...
[Шаг 5] Переход к основной задаче...
[Шаг 6] Решение основной задачи...
+ Оптимальное решение найдено

============================================================
Результат
============================================================

Оптимальная точка x*:
  x_1 = 9.000000
  x_2 = 0.000000
  x_3 = 0.000000
  x_4 = 7.000000

Значение целевой функции W(x*): 57.000000
Количество итераций: 6

[Шаг 7] Запись результата в файл output.txt...
+ Результат записан в файл

============================================================
Успешное завершение
============================================================
```

#### Шаг 4: Содержимое `output.txt`

```
Тип задачи: MAX
Целевая функция: 4x_1 + 1x_2 + 2x_3 + 3x_4

Оптимальная точка x*:
  x_1 = 9.000000
  x_2 = 0.000000
  x_3 = 0.000000
  x_4 = 7.000000

Значение целевой функции W(x*): 57.000000

Количество итераций: 6
```

### Пояснения к решению

#### 1. Приведение к каноническому виду

**Исходная задача:**

**Целевая функция:**
`max z = 4x₁ + 1x₂ + 2x₃ + 3x₄`

**Ограничения:**

```
1) x₁ + x₂ + x₃ ≤ 9
2) x₂ + 2x₃ + x₄ = 7
3) x₁ + x₄ ≥ 3
```

и `x₁, x₂, x₃, x₄ ≥ 0`.

---

Чтобы применить симплекс-метод, нужно, чтобы все ограничения были равенствами.
Для этого вводим дополнительные переменные:

1. Для первого ограничения (`≤`) добавляем **slack-переменную** `s₁ ≥ 0`:

   ```
   x₁ + x₂ + x₃ + s₁ = 9
   ```

2. Второе ограничение — это равенство, поэтому для начала симплекса вводим **искусственную переменную** `r₁ ≥ 0`:

   ```
   x₂ + 2x₃ + x₄ + r₁ = 7
   ```

3. Для третьего ограничения (`≥`) добавляем **surplus-переменную** и **искусственную переменную**:

   ```
   x₁ + x₄ - s₂ + r₂ = 3
   ```

**Приведённая система:**

```
x₁ + x₂ + x₃ + s₁           = 9
      x₂ + 2x₃ + x₄ + r₁    = 7
x₁         + x₄ - s₂ + r₂   = 3
```

---

#### 2. Фаза 1 — Вспомогательная задача

Формируется вспомогательная целевая функция:

```
min W = r₁ + r₂
```

После решения вспомогательной задачи получено:

```
W = 0
```

Это значит, что допустимое базисное решение найдено,
а искусственные переменные вышли из базиса (`r₁ = 0`, `r₂ = 0`).

---

#### 3. Фаза 2 — Основная задача

**Исходная целевая функция:**

```
max z = 4x₁ + 1x₂ + 2x₃ + 3x₄
```

После 6 итераций симплекс-метода достигнут оптимум:
все коэффициенты при небазисных переменных в строке Z стали неотрицательными,
что подтверждает выполнение критерия оптимальности.

---

#### 4. Оптимальное решение

```
x₁* = 9
x₂* = 0
x₃* = 0
x₄* = 7
```

**Значение целевой функции:**

```
z* = 4×9 + 1×0 + 2×0 + 3×7 = 57
```

---

#### 5. Проверка ограничений

| № | Ограничение       | Подстановка    | Проверка    |
| - | ----------------- | -------------- | ----------- |
| 1 | x₁ + x₂ + x₃ ≤ 9  | 9 + 0 + 0 = 9  | выполняется |
| 2 | x₂ + 2x₃ + x₄ = 7 | 0 + 0 + 7 = 7  | выполняется |
| 3 | x₁ + x₄ ≥ 3       | 9 + 7 = 16 ≥ 3 | выполняется |

---

#### 6. Итог

**Оптимальное решение найдено:**

```
x* = (9, 0, 0, 7)
z* = 57
```

**Количество итераций:** 6

---

### Дополнительные примеры

#### Пример 2: Задача со свободными переменными

**input.txt:**
```
max: 3x_1 + 2x_2 - 1x_3
constraints:
    2x_1 + 1x_2 + 1x_3 <= 10
    1x_1 - 1x_2 + 2x_3 >= 5
    1x_1 + 1x_2 + 1x_3 = 8
free_variables: x_3
```

**Описание:**
В этой задаче переменная `x_3` является свободной — она может принимать любые значения, включая отрицательные. Переменные `x_1` и `x_2` остаются неотрицательными. Программа автоматически заменяет `x_3` на разность двух неотрицательных переменных `x_3 = x_3⁺ - x_3⁻` и находит оптимальное решение.

#### Пример 3: Задача минимизации

**input.txt:**
```
min: 2x_1 + 3x_2
constraints:
    1x_1 + 1x_2 >= 4
    2x_1 + 1x_2 >= 5
```

**Результат:**
```
Тип задачи: MIN
Целевая функция: 2x_1 + 3x_2

Оптимальная точка x*:
  x_1 = 1.000000
  x_2 = 3.000000

Значение целевой функции W(x*): 11.000000

Количество итераций: 2
```

#### Пример 4: Несовместная задача

**input.txt:**
```
max: 1x_1 + 1x_2
constraints:
    1x_1 + 1x_2 <= 1
    1x_1 + 1x_2 >= 5
```

**Результат:**
```
[Шаг 1] Считывание файла input.txt...
+ Файл успешно прочитан

Целевая функция: max z = 1x_1 + 1x_2
Количество переменных: 2
Количество ограничений: 2

Ограничения:
  1. 1x_1 + 1x_2 <= 1
  2. 1x_1 + 1x_2 >= 5

[Шаг 2] Приведение задачи к каноническому виду...
[Шаг 3-4] Формирование и решение вспомогательной задачи...
[Шаг 5] Переход к основной задаче...
[Шаг 6] Решение основной задачи...

============================================================
Ошибка
============================================================

Задача не имеет допустимых решений (несовместная система). Искусственная переменная x_5 осталась в базисе.

Решений нет.
============================================================
```

---

## Вывод

### Что было полезного

1. **Глубокое понимание симплекс-метода**
   - Раньше алгоритм казался абстрактным набором формул, но реализация с нуля показала логику каждого шага
   - Особенно полезно было понять двухфазный метод: зачем нужны искусственные переменные и как они помогают найти начальный допустимый базис
   - Стало ясно, почему метод гарантированно находит оптимум для ЗЛП

2. **Практические навыки программирования**
   - Научился структурировать сложный алгоритм в виде классов и методов
   - Практика работы с Fraction для точных вычислений вместо float
   - Опыт написания документации и комментариев на русском языке
   - Реализация полного цикла: от чтения файла до записи результата

3. **Обработка граничных случаев**
   - Понял, как обнаруживать несовместные задачи (искусственные переменные остаются в базисе)
   - Научился выявлять неограниченные задачи (все элементы ведущего столбца ≤ 0)
   - Познакомился с проблемой вырождения и зацикливания

4. **Численные методы**
   - Осознал важность проверки малых чисел при делении (EPSILON)
   - Понял, почему нужно ограничивать количество итераций
   - Увидел разницу между теоретической математикой и практическими вычислениями

### Трудности и способы их преодоления

1. **Понимание двухфазного метода**
   - **Трудность:** Сначала было непонятно, зачем нужна Фаза 1 и что такое искусственные переменные
   - **Решение:** Изучил несколько примеров вручную на бумаге, пошагово проследил, как искусственные переменные помогают построить начальный базис
   - **Результат:** Понял, что Фаза 1 - это отдельная вспомогательная задача минимизации, которая "подготавливает" базис для основной задачи

2. **Индексация и работа с таблицей**
   - **Трудность:** Постоянно путался в индексах: где строка целевой функции, где первое ограничение, откуда начинаются slack переменные
   - **Решение:** Ввёл именованные константы (OBJECTIVE_ROW, FIRST_CONSTRAINT_ROW, RHS_COLUMN) вместо магических чисел
   - **Результат:** Код стал читаемым, ошибки индексации исчезли

3. **Формат входных данных**
   - **Трудность:** Как парсить выражения типа "3x_1 + 2x_2 <= 10" и не запутаться в знаках
   - **Решение:** Разбил парсинг на этапы: сначала токенизация по пробелам, потом обработка каждого токена отдельно
   - **Результат:** Парсер получился простым и надёжным, легко расширяется

4. **Обработка типов ограничений**
   - **Трудность:** Каждый тип ограничения (<=, >=, =) требует своих дополнительных переменных
   - **Решение:** Создал таблицу соответствия:
     - `<=` → +slack
     - `>=` → -surplus + искусственная
     - `=` → +искусственная
   - **Результат:** Реализовал единообразную логику в одном методе

5. **Отладка итераций симплекс-метода**
   - **Трудность:** Алгоритм работал неправильно, но непонятно на каком шаге ошибка
   - **Решение:** Добавил подробные комментарии к каждому шагу, выводил промежуточные таблицы (потом убрал для чистоты)
   - **Результат:** Нашёл ошибку в обновлении базисных переменных - забыл обновлять список базиса после pivot операции

6. **Обработка исключений**
   - **Трудность:** Программа падала с cryptic ошибками типа "list index out of range"
   - **Решение:** Добавил try-except блоки с информативными сообщениями на русском языке для каждого типа ошибки
   - **Результат:** Теперь пользователь видит понятное сообщение: "Задача несовместна" вместо трассировки стека

7. **Тестирование**
   - **Трудность:** Как проверить правильность работы программы?
   - **Решение:** 
     - Решил несколько задач вручную и сравнил с результатом программы
     - Проверил результаты в MS Excel (Поиск решения)
     - Создал тестовые примеры для всех граничных случаев
   - **Результат:** Уверенность в корректности реализации

### Что оказалось бесполезным или избыточным

1. **Чрезмерная оптимизация**
   - Пытался оптимизировать работу с матрицами, но для учебных задач (4-5 переменных) это не дало выигрыша
   - Понял, что читаемость важнее скорости для учебного проекта

2. **Множество вспомогательных файлов**
   - Сначала создал много отдельных модулей (utils, parsers, formatters), но это усложнило структуру
   - Для данного проекта достаточно одного основного файла `simplex.py`

### Общие впечатления

**Положительные:**
- Получил глубокое понимание одного из фундаментальных алгоритмов оптимизации
- Научился реализовывать математические алгоритмы в коде
- Развил навыки отладки и тестирования численных методов
- Понял важность хорошей документации и комментариев

**Негативные:**
- Отладка численных методов заняла больше времени, чем ожидалось
- Некоторые детали (работа с Fraction, обработка вырождения) требовали дополнительного изучения

**Практическая ценность:**
Работа показала, что между математической теорией и рабочим кодом есть значительная разница. Теория даёт общую схему, но практическая реализация требует учёта множества деталей: численной устойчивости, граничных случаев, обработки ошибок. Это ценный опыт для будущей работы с любыми вычислительными алгоритмами.

Самое важное - я научился не просто программировать, а думать о том, как математический алгоритм работает под капотом, предвидеть проблемы и писать надёжный, понятный код.


